{"ast":null,"code":"var _jsxFileName = \"D:\\\\GitHub\\\\CodingKirby-s-MacBook\\\\client\\\\src\\\\contexts\\\\MemoContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport axios from 'axios';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MemoContext = /*#__PURE__*/createContext(undefined);\nexport const MemoProvider = ({\n  children\n}) => {\n  _s();\n  const [folders, setFolders] = useState([]);\n  const [memos, setMemos] = useState([]);\n  const [selectedFolder, setSelectedFolder] = useState(1);\n  const [selectedMemo, setSelectedMemo] = useState(null);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [isCreating, setIsCreating] = useState(false);\n  const [showPasswordModal, setShowPasswordModal] = useState(false);\n  const [showErrorModal, setShowErrorModal] = useState(false);\n  const [newMemo, setNewMemo] = useState({\n    title: '새로운 메모',\n    content: '작성 중...',\n    password: '0000',\n    folder_id: selectedFolder,\n    date: new Date().toLocaleString('ko-KR'),\n    id: 0\n  });\n\n  // 폴더 및 메모 불러오기\n  const fetchFoldersAndMemos = async () => {\n    try {\n      const [foldersResponse, memosResponse] = await Promise.all([axios.get('/folders'), axios.get('/memos')]);\n      setFolders(foldersResponse.data.folders);\n      const formattedMemos = memosResponse.data.memos.sort((a, b) => b.id - a.id).map(memo => ({\n        ...memo,\n        date: new Date(memo.created_at).toLocaleString('ko-KR')\n      }));\n      setMemos(formattedMemos);\n    } catch (error) {\n      console.error('Error fetching folders and memos:', error);\n    }\n  };\n\n  // 메모 상태 초기화\n  const resetMemoState = () => {\n    setSelectedMemo(null);\n    setSelectedFolder(1);\n    setIsCreating(false);\n    setShowPasswordModal(false);\n    setShowErrorModal(false);\n    setNewMemo({\n      title: '',\n      content: '',\n      password: '',\n      folder_id: 1,\n      date: new Date().toLocaleString('ko-KR'),\n      id: 0\n    });\n    setMemos(prevMemos => prevMemos.filter(memo => memo.id !== 0));\n  };\n\n  // 새 메모 생성 상태 초기화\n  const resetMemoCreateState = () => {\n    setIsCreating(false);\n    setShowPasswordModal(false);\n    setShowErrorModal(false);\n    setMemos(prevMemos => prevMemos.filter(memo => memo.id !== 0));\n    setSelectedMemo(null);\n    setNewMemo({\n      title: '',\n      content: '',\n      password: '',\n      folder_id: selectedFolder,\n      date: new Date().toLocaleString('ko-KR'),\n      id: 0\n    });\n  };\n\n  // 새 메모 생성\n  const createMemo = async () => {\n    if (!newMemo.title || !newMemo.content || !newMemo.password) {\n      setShowErrorModal(true);\n      return;\n    }\n    try {\n      const response = await axios.post('/memos', {\n        ...newMemo,\n        folder_id: selectedFolder\n      });\n      const createdMemo = {\n        ...newMemo,\n        id: response.data.memo.id,\n        date: new Date(response.data.memo.created_at).toLocaleString('ko-KR')\n      };\n      resetMemoCreateState();\n      setMemos(prevMemos => [createdMemo, ...prevMemos.filter(memo => memo.id !== 0)]);\n      setSelectedMemo(createdMemo);\n      console.log('Memo created:', createdMemo);\n    } catch (error) {\n      console.error('Error saving memo:', error);\n    }\n  };\n\n  // 메모 삭제\n  const deleteMemo = async (id, password) => {\n    try {\n      await axios.delete(`/memos/${id}`, {\n        data: {\n          password\n        }\n      });\n      fetchFoldersAndMemos();\n      return true; // 성공 시 true 반환\n    } catch (error) {\n      console.error('Error deleting memo:', error);\n      return false; // 실패 시 false 반환\n    }\n  };\n\n  // 폴더 변경 시 처리\n  useEffect(() => {\n    if (isCreating) {\n      setNewMemo({\n        ...newMemo,\n        folder_id: selectedFolder\n      });\n    }\n    fetchFoldersAndSetMemoOnFolderChange();\n  }, [selectedFolder]);\n\n  // 메모 편집 중 리스트 동기화\n  useEffect(() => {\n    if (selectedMemo && selectedMemo.id === newMemo.id) {\n      setMemos(prevMemos => prevMemos.map(memo => memo.id === newMemo.id ? {\n        ...memo,\n        ...newMemo\n      } : memo));\n    }\n  }, [newMemo, selectedMemo, setMemos]);\n\n  // 폴더와 메모 변경 처리\n  const fetchFoldersAndSetFirstMemo = async () => {\n    await fetchFoldersAndMemos();\n    setFirstMemoForSelectedFolder();\n  };\n  const setFirstMemoForSelectedFolder = () => {\n    const folderMemos = filterMemosByFolder(selectedFolder);\n    setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\n  };\n  const fetchFoldersAndSetSelectedMemo = async () => {\n    await fetchFoldersAndMemos();\n    selectMemoIfExists();\n  };\n  const selectMemoIfExists = () => {\n    const selectedMemoId = memos.find(memo => memo.id === (selectedMemo === null || selectedMemo === void 0 ? void 0 : selectedMemo.id));\n    if (selectedMemoId) setSelectedMemo(selectedMemoId);\n  };\n  const fetchFoldersAndSetMemoOnFolderChange = async () => {\n    await fetchFoldersAndMemos();\n\n    // 폴더 변경 후 새 메모 생성 시 임시 메모가 제대로 추가되도록 로직 수정\n    if (isCreating) {\n      const tempMemo = {\n        ...newMemo,\n        folder_id: selectedFolder\n      };\n\n      // 현재 선택된 폴더에 맞는 임시 메모를 추가\n      updateMemosWithNewMemo(tempMemo);\n    } else {\n      // 폴더 변경 후 선택된 폴더에 맞는 첫 번째 메모를 선택\n      const folderMemos = filterMemosByFolder(selectedFolder);\n      setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\n    }\n  };\n  const updateMemoOnFolderChange = () => {\n    const folderMemos = filterMemosByFolder(selectedFolder);\n    if (!isCreating) {\n      setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\n    } else {\n      setNewMemoAndSelect();\n    }\n  };\n  const filterMemosByFolder = folderId => folderId === 1 ? memos : memos.filter(memo => memo.folder_id === folderId);\n  const setNewMemoAndSelect = () => {\n    const tempMemo = {\n      ...newMemo,\n      folder_id: selectedFolder\n    };\n    updateMemosWithNewMemo(tempMemo);\n  };\n  const updateMemosWithNewMemo = tempMemo => {\n    setMemos([tempMemo, ...memos.filter(memo => memo.id !== newMemo.id)]);\n    setSelectedMemo(tempMemo);\n  };\n\n  // 검색어와 폴더에 맞는 메모 필터링\n  const matchesSearchQuery = memo => {\n    var _memo$title, _memo$content;\n    return ((_memo$title = memo.title) === null || _memo$title === void 0 ? void 0 : _memo$title.includes(searchQuery)) || '' || ((_memo$content = memo.content) === null || _memo$content === void 0 ? void 0 : _memo$content.includes(searchQuery)) || '';\n  };\n  const filteredMemos = memos.filter(memo => {\n    const isInSelectedFolder = selectedFolder === 1 || memo.folder_id === selectedFolder;\n    return isInSelectedFolder && matchesSearchQuery(memo);\n  }).sort((a, b) => {\n    // 임시 메모(id === 0)를 항상 최상단에\n    if (a.id === 0) return -1;\n    if (b.id === 0) return 1;\n\n    // 고정 메모(id === 1)를 그 다음에 위치\n    if (a.id === 1) return -1;\n    if (b.id === 1) return 1;\n\n    // 그 외 메모는 id 기준으로 내림차순 정렬\n    return b.id - a.id;\n  });\n  return /*#__PURE__*/_jsxDEV(MemoContext.Provider, {\n    value: {\n      folders,\n      memos,\n      selectedMemo,\n      searchQuery,\n      selectedFolder,\n      isCreating,\n      showPasswordModal,\n      showErrorModal,\n      newMemo,\n      setFolders,\n      setMemos,\n      setSelectedMemo,\n      setSearchQuery,\n      setSelectedFolder,\n      setIsCreating,\n      setShowPasswordModal,\n      setShowErrorModal,\n      setNewMemo,\n      fetchFoldersAndMemos,\n      createMemo,\n      deleteMemo,\n      resetMemoState,\n      resetMemoCreateState,\n      filteredMemos,\n      fetchFoldersAndSetFirstMemo,\n      setFirstMemoForSelectedFolder,\n      fetchFoldersAndSetSelectedMemo,\n      selectMemoIfExists,\n      fetchFoldersAndSetMemoOnFolderChange,\n      updateMemoOnFolderChange,\n      filterMemosByFolder,\n      setNewMemoAndSelect,\n      updateMemosWithNewMemo,\n      matchesSearchQuery\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 213,\n    columnNumber: 5\n  }, this);\n};\n_s(MemoProvider, \"ykqNwzg2e9Y69hCYFcjcil7yP7I=\");\n_c = MemoProvider;\nexport const useMemoContext = () => {\n  _s2();\n  const context = useContext(MemoContext);\n  if (!context) {\n    throw new Error('useMemoContext must be used within a MemoProvider');\n  }\n  return context;\n};\n_s2(useMemoContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MemoProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","axios","jsxDEV","_jsxDEV","MemoContext","undefined","MemoProvider","children","_s","folders","setFolders","memos","setMemos","selectedFolder","setSelectedFolder","selectedMemo","setSelectedMemo","searchQuery","setSearchQuery","isCreating","setIsCreating","showPasswordModal","setShowPasswordModal","showErrorModal","setShowErrorModal","newMemo","setNewMemo","title","content","password","folder_id","date","Date","toLocaleString","id","fetchFoldersAndMemos","foldersResponse","memosResponse","Promise","all","get","data","formattedMemos","sort","a","b","map","memo","created_at","error","console","resetMemoState","prevMemos","filter","resetMemoCreateState","createMemo","response","post","createdMemo","log","deleteMemo","delete","fetchFoldersAndSetMemoOnFolderChange","fetchFoldersAndSetFirstMemo","setFirstMemoForSelectedFolder","folderMemos","filterMemosByFolder","length","fetchFoldersAndSetSelectedMemo","selectMemoIfExists","selectedMemoId","find","tempMemo","updateMemosWithNewMemo","updateMemoOnFolderChange","setNewMemoAndSelect","folderId","matchesSearchQuery","_memo$title","_memo$content","includes","filteredMemos","isInSelectedFolder","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useMemoContext","_s2","context","Error","$RefreshReg$"],"sources":["D:/GitHub/CodingKirby-s-MacBook/client/src/contexts/MemoContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\r\nimport axios from 'axios';\r\nimport { Folder, Memo, MemoContextProps } from '../types/MemoTypes';\r\n\r\nconst MemoContext = createContext<MemoContextProps | undefined>(undefined);\r\n\r\nexport const MemoProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const [folders, setFolders] = useState<Folder[]>([]);\r\n  const [memos, setMemos] = useState<Memo[]>([]);\r\n  const [selectedFolder, setSelectedFolder] = useState<number>(1);\r\n  const [selectedMemo, setSelectedMemo] = useState<Memo | null>(null);\r\n  const [searchQuery, setSearchQuery] = useState<string>('');\r\n  const [isCreating, setIsCreating] = useState<boolean>(false);\r\n  const [showPasswordModal, setShowPasswordModal] = useState<boolean>(false);\r\n  const [showErrorModal, setShowErrorModal] = useState<boolean>(false);\r\n  const [newMemo, setNewMemo] = useState<Memo>({\r\n    title: '새로운 메모',\r\n    content: '작성 중...',\r\n    password: '0000',\r\n    folder_id: selectedFolder,\r\n    date: new Date().toLocaleString('ko-KR'),\r\n    id: 0,\r\n  });\r\n\r\n  // 폴더 및 메모 불러오기\r\n  const fetchFoldersAndMemos = async () => {\r\n    try {\r\n      const [foldersResponse, memosResponse] = await Promise.all([\r\n        axios.get('/folders'),\r\n        axios.get('/memos'),\r\n      ]);\r\n      setFolders(foldersResponse.data.folders);\r\n      const formattedMemos = memosResponse.data.memos\r\n        .sort((a: Memo, b: Memo) => b.id - a.id)\r\n        .map((memo: any) => ({\r\n          ...memo,\r\n          date: new Date(memo.created_at).toLocaleString('ko-KR'),\r\n        }));\r\n      setMemos(formattedMemos);\r\n    } catch (error) {\r\n      console.error('Error fetching folders and memos:', error);\r\n    }\r\n  };\r\n\r\n  // 메모 상태 초기화\r\n  const resetMemoState = () => {\r\n    setSelectedMemo(null);\r\n    setSelectedFolder(1);\r\n    setIsCreating(false);\r\n    setShowPasswordModal(false);\r\n    setShowErrorModal(false);\r\n    setNewMemo({\r\n      title: '',\r\n      content: '',\r\n      password: '',\r\n      folder_id: 1,\r\n      date: new Date().toLocaleString('ko-KR'),\r\n      id: 0,\r\n    });\r\n    setMemos((prevMemos) => prevMemos.filter((memo) => memo.id !== 0));\r\n  };\r\n\r\n  // 새 메모 생성 상태 초기화\r\n  const resetMemoCreateState = () => {\r\n    setIsCreating(false);\r\n    setShowPasswordModal(false);\r\n    setShowErrorModal(false);\r\n    setMemos((prevMemos) => prevMemos.filter((memo) => memo.id !== 0));\r\n    setSelectedMemo(null);\r\n    setNewMemo({\r\n      title: '',\r\n      content: '',\r\n      password: '',\r\n      folder_id: selectedFolder,\r\n      date: new Date().toLocaleString('ko-KR'),\r\n      id: 0,\r\n    });\r\n  };\r\n\r\n  // 새 메모 생성\r\n  const createMemo = async () => {\r\n    if (!newMemo.title || !newMemo.content || !newMemo.password) {\r\n      setShowErrorModal(true);\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('/memos', { ...newMemo, folder_id: selectedFolder });\r\n      const createdMemo = {\r\n        ...newMemo,\r\n        id: response.data.memo.id,\r\n        date: new Date(response.data.memo.created_at).toLocaleString('ko-KR'),\r\n      };\r\n      resetMemoCreateState();\r\n      setMemos((prevMemos) => [createdMemo, ...prevMemos.filter((memo) => memo.id !== 0)]);\r\n      setSelectedMemo(createdMemo);\r\n      console.log('Memo created:', createdMemo);\r\n    } catch (error) {\r\n      console.error('Error saving memo:', error);\r\n    }\r\n  };\r\n\r\n  // 메모 삭제\r\n  const deleteMemo = async (id: string, password: string): Promise<boolean> => {\r\n    try {\r\n      await axios.delete(`/memos/${id}`, { data: { password } });\r\n      fetchFoldersAndMemos();\r\n      return true;  // 성공 시 true 반환\r\n    } catch (error) {\r\n      console.error('Error deleting memo:', error);\r\n      return false;  // 실패 시 false 반환\r\n    }\r\n  };\r\n\r\n  // 폴더 변경 시 처리\r\n  useEffect(() => {\r\n    if (isCreating) {\r\n      setNewMemo({ ...newMemo, folder_id: selectedFolder });\r\n    }\r\n    fetchFoldersAndSetMemoOnFolderChange();\r\n  }, [selectedFolder]);\r\n\r\n  // 메모 편집 중 리스트 동기화\r\n  useEffect(() => {\r\n    if (selectedMemo && selectedMemo.id === newMemo.id) {\r\n      setMemos((prevMemos) =>\r\n        prevMemos.map((memo) => (memo.id === newMemo.id ? { ...memo, ...newMemo } : memo))\r\n      );\r\n    }\r\n  }, [newMemo, selectedMemo, setMemos]);\r\n\r\n  // 폴더와 메모 변경 처리\r\n  const fetchFoldersAndSetFirstMemo = async () => {\r\n    await fetchFoldersAndMemos();\r\n    setFirstMemoForSelectedFolder();\r\n  };\r\n\r\n  const setFirstMemoForSelectedFolder = () => {\r\n    const folderMemos = filterMemosByFolder(selectedFolder);\r\n    setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\r\n  };\r\n\r\n  const fetchFoldersAndSetSelectedMemo = async () => {\r\n    await fetchFoldersAndMemos();\r\n    selectMemoIfExists();\r\n  };\r\n\r\n  const selectMemoIfExists = () => {\r\n    const selectedMemoId = memos.find((memo) => memo.id === selectedMemo?.id);\r\n    if (selectedMemoId) setSelectedMemo(selectedMemoId);\r\n  };\r\n\r\n  const fetchFoldersAndSetMemoOnFolderChange = async () => {\r\n    await fetchFoldersAndMemos();\r\n    \r\n    // 폴더 변경 후 새 메모 생성 시 임시 메모가 제대로 추가되도록 로직 수정\r\n    if (isCreating) {\r\n      const tempMemo = { ...newMemo, folder_id: selectedFolder };\r\n      \r\n      // 현재 선택된 폴더에 맞는 임시 메모를 추가\r\n      updateMemosWithNewMemo(tempMemo);\r\n    } else {\r\n      // 폴더 변경 후 선택된 폴더에 맞는 첫 번째 메모를 선택\r\n      const folderMemos = filterMemosByFolder(selectedFolder);\r\n      setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\r\n    }\r\n  };  \r\n\r\n  const updateMemoOnFolderChange = () => {\r\n    const folderMemos = filterMemosByFolder(selectedFolder);\r\n    if (!isCreating) {\r\n      setSelectedMemo(folderMemos.length ? folderMemos[0] : null);\r\n    } else {\r\n      setNewMemoAndSelect();\r\n    }\r\n  };\r\n\r\n  const filterMemosByFolder = (folderId: number) =>\r\n    folderId === 1 ? memos : memos.filter((memo) => memo.folder_id === folderId);\r\n\r\n  const setNewMemoAndSelect = () => {\r\n    const tempMemo = { ...newMemo, folder_id: selectedFolder };\r\n    updateMemosWithNewMemo(tempMemo);\r\n  };\r\n\r\n  const updateMemosWithNewMemo = (tempMemo: any) => {\r\n    setMemos([tempMemo, ...memos.filter((memo) => memo.id !== newMemo.id)]);\r\n    setSelectedMemo(tempMemo);\r\n  };\r\n\r\n  // 검색어와 폴더에 맞는 메모 필터링\r\n  const matchesSearchQuery = (memo: any) =>\r\n    (memo.title?.includes(searchQuery) || '') || (memo.content?.includes(searchQuery) || '');\r\n\r\n  const filteredMemos = memos\r\n  .filter((memo) => {\r\n    const isInSelectedFolder = selectedFolder === 1 || memo.folder_id === selectedFolder;\r\n    return isInSelectedFolder && matchesSearchQuery(memo);\r\n  })\r\n  .sort((a, b) => {\r\n    // 임시 메모(id === 0)를 항상 최상단에\r\n    if (a.id === 0) return -1;\r\n    if (b.id === 0) return 1;\r\n\r\n    // 고정 메모(id === 1)를 그 다음에 위치\r\n    if (a.id === 1) return -1;\r\n    if (b.id === 1) return 1;\r\n\r\n    // 그 외 메모는 id 기준으로 내림차순 정렬\r\n    return b.id - a.id;\r\n  });\r\n\r\n  return (\r\n    <MemoContext.Provider\r\n      value={{\r\n        folders,\r\n        memos,\r\n        selectedMemo,\r\n        searchQuery,\r\n        selectedFolder,\r\n        isCreating,\r\n        showPasswordModal,\r\n        showErrorModal,\r\n        newMemo,\r\n        setFolders,\r\n        setMemos,\r\n        setSelectedMemo,\r\n        setSearchQuery,\r\n        setSelectedFolder,\r\n        setIsCreating,\r\n        setShowPasswordModal,\r\n        setShowErrorModal,\r\n        setNewMemo,\r\n        fetchFoldersAndMemos,\r\n        createMemo,\r\n        deleteMemo,\r\n        resetMemoState,\r\n        resetMemoCreateState,\r\n        filteredMemos,\r\n        fetchFoldersAndSetFirstMemo,\r\n        setFirstMemoForSelectedFolder,\r\n        fetchFoldersAndSetSelectedMemo,\r\n        selectMemoIfExists,\r\n        fetchFoldersAndSetMemoOnFolderChange,\r\n        updateMemoOnFolderChange,\r\n        filterMemosByFolder,\r\n        setNewMemoAndSelect,\r\n        updateMemosWithNewMemo,\r\n        matchesSearchQuery,\r\n      }}\r\n    >\r\n      {children}\r\n    </MemoContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useMemoContext = () => {\r\n  const context = useContext(MemoContext);\r\n  if (!context) {\r\n    throw new Error('useMemoContext must be used within a MemoProvider');\r\n  }\r\n  return context;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}